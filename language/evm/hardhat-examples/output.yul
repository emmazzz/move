/* =======================================
 * Generated by Move-To-Yul compiler v0.0
 * ======================================= */

/// @use-src 1:"contracts/ERC20Mock.move"
///        , 2:"../stdlib/sources/U256.move"
///        , 3:"../stdlib/sources/Table.move"
///        , 4:"../stdlib/sources/Evm.move"


object "A2_ERC20Mock" {
    code {
        mstore(0, memoryguard(160))
        let program_size := datasize("A2_ERC20Mock")
        let arg_size := sub(codesize(), program_size)
        let memory_data_offset := $Malloc(arg_size)
        codecopy(memory_data_offset, program_size, arg_size)
        let param_0, param_1, param_2, param_3 := abi_decode_tuple_$string_string_address_uint256$_$vec$u8$_vec$u8$_address_A2_U256_U256$_from_memory(memory_data_offset, add(memory_data_offset, arg_size))
        A2_ERC20Mock_create(param_0, param_1, param_2, param_3)
        codecopy(0, dataoffset("A2_ERC20Mock_deployed"), datasize("A2_ERC20Mock_deployed"))
        return(0, datasize("A2_ERC20Mock_deployed"))
        function A2_ERC20Mock_create(name, symbol, initial_account, initial_balance) {
            let tmp_$4, tmp_$5, tmp_$6, tmp_$7, tmp_$8, tmp_$10, $t11, $t12, $t13, $t14, $t15, $t16
            let $locals := $Malloc(32)
            // $t11 := Evm::self()
            /// @src 1:2137:2143
            $t11 := A2_Evm_self()
            // $t9 := Evm::sign($t11)
            /// @src 1:2132:2144
            mstore($locals, A2_Evm_sign($t11))
            // $t12 := borrow_local($t9)
            /// @src 1:2131:2144
            $t12 := $MakePtr(false, $locals)
            // $t13 := U256::zero()
            /// @src 1:2196:2208
            $t13 := A2_U256_zero()
            // $t14 := Table::empty<address, U256::U256>()
            /// @src 1:2236:2265
            $t14 := A2_Table_empty$address_A2_U256_U256$()
            // $t15 := Table::empty<address, Table::Table<address, U256::U256>>()
            /// @src 1:2295:2340
            $t15 := A2_Table_empty$address_A2_Table_Table$address_A2_U256_U256$$()
            // $t16 := pack ERC20Mock::State($t14, $t15, $t13, $t0, $t1)
            /// @src 1:2158:2401
            {
                let $mem := $Malloc(160)
                $MemoryStoreU256(add($mem, 64), $t14)
                $MemoryStoreU256(add($mem, 96), $t15)
                $MemoryStoreU256(add($mem, 128), $t13)
                $MemoryStoreU256(add($mem, 0), name)
                $MemoryStoreU256(add($mem, 32), symbol)
                $t16 := $mem
            }
            // move_to<ERC20Mock::State>($t16, $t12)
            /// @src 1:2103:2110
            {
                let $base_offset := $MakeTypeStorageBase(0, 0xa937cc63, $LoadU256($t12))
                if $AlignedStorageLoad($base_offset) {
                  $AbortBuiltin()
                }
                $AlignedStorageStore($base_offset, true)
                {
                    let $dst := add($base_offset, 32)
                    let $src := $t16
                    {
                        let $linked_src_2300595445 := mload(add($src, 0))
                        let $linked_dst_2300595445 := $NewLinkedStorageBase(0x89204cf5)
                        let $size_2300595445 := $MemoryLoadU64($linked_src_2300595445)
                        let $data_size_2300595445 := mul($size_2300595445, 1)
                        $AlignedStorageStore($linked_dst_2300595445, mload($linked_src_2300595445))
                        let $data_src_2300595445 := add($linked_src_2300595445, 32)
                        let $data_dst_2300595445 := add($linked_dst_2300595445, 32)
                        for { let $offs_2300595445 := 0 } lt($offs_2300595445, $data_size_2300595445) { $offs_2300595445 := add($offs_2300595445, 32)} {
                            $AlignedStorageStore(add($data_dst_2300595445, $offs_2300595445), mload(add($data_src_2300595445, $offs_2300595445)))
                            $Free($linked_src_2300595445, add($data_size_2300595445, 32))
                        }
                        $AlignedStorageStore(add($dst, 0), $linked_dst_2300595445)
                    }
                    {
                        let $linked_src_2300595445 := mload(add($src, 32))
                        let $linked_dst_2300595445 := $NewLinkedStorageBase(0x89204cf5)
                        let $size_2300595445 := $MemoryLoadU64($linked_src_2300595445)
                        let $data_size_2300595445 := mul($size_2300595445, 1)
                        $AlignedStorageStore($linked_dst_2300595445, mload($linked_src_2300595445))
                        let $data_src_2300595445 := add($linked_src_2300595445, 32)
                        let $data_dst_2300595445 := add($linked_dst_2300595445, 32)
                        for { let $offs_2300595445 := 0 } lt($offs_2300595445, $data_size_2300595445) { $offs_2300595445 := add($offs_2300595445, 32)} {
                            $AlignedStorageStore(add($data_dst_2300595445, $offs_2300595445), mload(add($data_src_2300595445, $offs_2300595445)))
                            $Free($linked_src_2300595445, add($data_size_2300595445, 32))
                        }
                        $AlignedStorageStore(add($dst, 32), $linked_dst_2300595445)
                    }
                    $AlignedStorageStore(add($dst, 64), mload(add($src, 64)))
                    $AlignedStorageStore(add($dst, 96), mload(add($src, 96)))
                    $AlignedStorageStore(add($dst, 128), mload(add($src, 128)))
                    $Free($src, 160)
                }
            }
            // ERC20Mock::mint_($t2, $t3)
            /// @src 1:2459:2498
            A2_ERC20Mock_mint_(initial_account, initial_balance)
            // return ()
            /// @src 1:2498:2499
            $Free($locals, 32)
        }

        function A2_ERC20Mock_mint_(account, amount) {
            let mut_bal_account, s, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17
            // $t4 := 0x0
            /// @src 1:8739:8743
            $t4 := 0x0
            // $t5 := !=($t0, $t4)
            /// @src 1:8736:8738
            $t5 := $Neq(account, $t4)
            // $t6 := [69, 82, 67, 50, 48, 58, 32, 109, 105, 110, 116, 32, 116, 111, 32, 116, 104, 101, 32, 122, 101, 114, 111, 32, 97, 100, 100, 114, 101, 115, 115]
            /// @src 1:8745:8779
            $t6 := $Malloc(63)
            $MemoryStoreU64($t6, 31)
            $MemoryStoreU64(add($t6, 8), $ClosestGreaterPowerOfTwo(63))
            let $offs_473435132 := add($t6, 32)
            $MemoryStoreU8($offs_473435132, 69)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 82)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 67)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 50)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 48)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 58)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 32)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 109)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 105)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 110)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 116)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 32)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 116)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 111)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 32)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 116)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 104)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 101)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 32)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 122)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 101)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 114)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 111)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 32)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 97)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 100)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 100)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 114)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 101)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 115)
            $offs_473435132 := add($offs_473435132, 1)
            $MemoryStoreU8($offs_473435132, 115)
            $offs_473435132 := add($offs_473435132, 1)
            // Evm::require($t5, $t6)
            /// @src 1:8720:8780
            A2_Evm_require($t5, $t6)
            // $t7 := Evm::self()
            /// @src 1:8823:8829
            $t7 := A2_Evm_self()
            // $t8 := borrow_global<ERC20Mock::State>($t7)
            /// @src 1:8798:8815
            {
                let $base_offset := $MakeTypeStorageBase(0, 0xa937cc63, $t7)
                if iszero($AlignedStorageLoad($base_offset)) {
                  $AbortBuiltin()
                }
                $t8 := $MakePtr(true, add($base_offset, 32))
            }
            // $t9 := borrow_field<ERC20Mock::State>.total_supply($t8)
            /// @src 1:8867:8881
            $t9 := $IndexPtr($t8, 128)
            // $t10 := read_ref($t9)
            /// @src 1:8867:8881
            $t10 := $LoadU256($t9)
            // $t11 := +($t10, $t1)
            /// @src 1:8857:8890
            $t11 := $AddU256($t10, amount)
            // $t12 := borrow_field<ERC20Mock::State>.total_supply($t8)
            /// @src 1:8840:8854
            $t12 := $IndexPtr($t8, 128)
            // write_ref($t12, $t11)
            /// @src 1:8840:8890
            $StoreU256($t12, $t11)
            // $t13 := ERC20Mock::mut_balanceOf($t8, $t0)
            /// @src 1:8922:8947
            $t13 := A2_ERC20Mock_mut_balanceOf($t8, account)
            // $t14 := read_ref($t13)
            /// @src 1:8986:9002
            $t14 := $LoadU256($t13)
            // $t15 := +($t14, $t1)
            /// @src 1:8976:9011
            $t15 := $AddU256($t14, amount)
            // write_ref($t13, $t15)
            /// @src 1:8957:9011
            $StoreU256($t13, $t15)
            // $t16 := 0x0
            /// @src 1:9041:9045
            $t16 := 0x0
            // $t17 := pack ERC20Mock::Transfer($t16, $t0, $t1)
            /// @src 1:9026:9074
            {
                let $mem := $Malloc(96)
                $MemoryStoreU256(add($mem, 0), $t16)
                $MemoryStoreU256(add($mem, 32), account)
                $MemoryStoreU256(add($mem, 64), amount)
                $t17 := $mem
            }
            // Evm::emit<ERC20Mock::Transfer>($t17)
            /// @src 1:9021:9075
            A2_Evm_emit$A2_ERC20Mock_Transfer$($t17)
            // return ()
            /// @src 1:9075:9076
        }

        function A2_Evm_emit$A2_ERC20Mock_Transfer$(e) {
            let $t1 := 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
            let $t2 := $MemoryLoadU256(add(e, 0))
            let $t3 := $MemoryLoadU256(add(e, 32))
            let $t4 := $MemoryLoadU256(add(e, 64))
            {
                let $t5 := mload(0)
                let $t6 := abi_encode_tuple_$uint256$_$A2_U256_U256$($t5, $t4)
                log3($t5, sub($t6, $t5), $t1,$t2,$t3)
            }
        }
        function A2_ERC20Mock_mut_balanceOf(s, owner) -> $result {
            let $t2, $t3, $t4, $t5
            let $locals := $Malloc(32)
            mstore($locals, owner)
            // $t2 := borrow_field<ERC20Mock::State>.balances($t0)
            /// @src 1:8504:8519
            $t2 := $IndexPtr(s, 64)
            // $t3 := borrow_local($t1)
            /// @src 1:8521:8527
            $t3 := $MakePtr(false, $locals)
            // $t4 := U256::zero()
            /// @src 1:8529:8541
            $t4 := A2_U256_zero()
            // $t5 := Table::borrow_mut_with_default<address, U256::U256>($t2, $t3, $t4)
            /// @src 1:8473:8542
            $t5 := A2_Table_borrow_mut_with_default$address_A2_U256_U256$($t2, $t3, $t4)
            // return $t5
            /// @src 1:8473:8542
            $result := $t5
            $Free($locals, 32)
        }

        function A2_Table_borrow_mut_with_default$address_A2_U256_U256$(table, key, default_value) -> $result {
            let tmp_$3, tmp_$4, $t5, $t6, $t7, $t8
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L0
                    // Table::insert<#0, #1>($t0, $t1, $t2)
                    /// @src 3:903:936
                    A2_Table_insert$address_A2_U256_U256$(table, key, default_value)
                    // goto L2
                    /// @src 3:967:972
                    $block := 3
                }
                case 3 {
                    // label L2
                    // $t8 := Table::borrow_mut<#0, #1>($t0, $t1)
                    /// @src 3:956:978
                    $t8 := A2_Table_borrow_mut$address_A2_U256_U256$(table, key)
                    // return $t8
                    /// @src 3:956:978
                    $result := $t8
                    leave
                }
                case 4 {
                    // $t5 := freeze_ref($t0)
                    /// @src 3:875:887
                    $t5 := table
                    // $t6 := Table::contains<#0, #1>($t5, $t1)
                    /// @src 3:867:887
                    $t6 := A2_Table_contains$address_A2_U256_U256$($t5, key)
                    // $t7 := !($t6)
                    /// @src 3:866:867
                    $t7 := $LogicalNot($t6)
                    // if ($t7) goto L0 else goto L2
                    /// @src 3:862:946
                    switch $t7
                    case 0  { $block := 3 }
                    default { $block := 2 }
                }
            }
        }

        function A2_Table_contains$address_A2_U256_U256$(table_ref, key_ref) -> res {
            let key := $LoadU256(key_ref)
            let table_handle := $LoadU256(table_ref)
            let storage_key := $StorageKey(table_handle, key)
            let word := sload(storage_key)
            res := $LogicalNot(iszero(word))
        }
        function A2_Table_borrow_mut$address_A2_U256_U256$(table_ref, key_ref) -> value_ref {
            let key := $LoadU256(key_ref)
            let table_handle := $LoadU256(table_ref)
            let storage_key := $StorageKey(table_handle, key)
            let value_offs := sload(storage_key)
            if iszero(value_offs) {
              $AbortBuiltin()
            }
            value_ref := $MakePtr(true, value_offs)
        }
        function A2_Table_insert$address_A2_U256_U256$(table_ref, key_ref, value) {
            let key := $LoadU256(key_ref)
            let table_handle := $LoadU256(table_ref)
            let storage_key := $StorageKey(table_handle, key)
            let word := sload(storage_key)
            if $LogicalNot(iszero(word)) {
              $AbortBuiltin()
            }
            let $linked_dst_2934085429 := $NewLinkedStorageBase(0xaee29735)
            $StorageStoreU256($linked_dst_2934085429, value)
            sstore(storage_key, $linked_dst_2934085429)
        }
        function A2_U256_zero() -> $result {
            let $t0
            // $t0 := 0
            /// @src 2:991:1012
            $t0 := 0
            // return $t0
            /// @src 2:991:1012
            $result := $t0
        }

        function A2_Evm_self() -> addr {
          addr := address()
        }
        function A2_Evm_require(cond, message) {
            let $t2
            let $block := 4
            for {} true {} {
                switch $block
                case 2 {
                    // label L0
                    // Evm::abort_with($t1)
                    /// @src 4:2825:2844
                    A2_Evm_abort_with(message)
                    // goto L2
                    /// @src 4:2812:2847
                    $block := 3
                }
                case 3 {
                    // label L2
                    // return ()
                    /// @src 4:2812:2847
                    leave
                }
                case 4 {
                    // $t2 := !($t0)
                    /// @src 4:2816:2817
                    $t2 := $LogicalNot(cond)
                    // if ($t2) goto L0 else goto L2
                    /// @src 4:2812:2847
                    switch $t2
                    case 0  { $block := 3 }
                    default { $block := 2 }
                }
            }
        }

        function A2_Evm_abort_with(message) {
          let head := $Malloc(32)
          // store the function selector for Error(string)
          mstore(head, 3963877391197344453575983046348115674221700746820753546331534351508065746944)
          let pos := add(head, 4)
          mstore(pos, 32)
          pos := add(pos, 32)
          let size := $MemoryLoadU64(message)
          mstore(pos, size)
          pos := add(pos, 32)
          $CopyMemoryU8(add(message, 32), pos, size)
          size := $RoundUp(size)
          let end := add(pos, size)
          revert(head, sub(end, head))
        }
        function A2_Table_empty$address_A2_Table_Table$address_A2_U256_U256$$() -> table {
            table := $NewTableHandle()
        }
        function A2_Table_empty$address_A2_U256_U256$() -> table {
            table := $NewTableHandle()
        }
        function A2_Evm_sign(addr) -> signer {
          signer := addr
        }
        function abi_encode_tuple_$uint256$_$A2_U256_U256$(headStart ,value_0) -> tail {
            tail := add(headStart, 32)
            abi_encode_uint256(value_0, add(headStart, 0))
        }
        function abi_encode_uint256(value, pos) {
            mstore(pos, cleanup_uint256(value))
        }
        function cleanup_uint256(value) -> cleaned {
            cleaned := and(value, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)
        }
        function abi_decode_tuple_$string_string_address_uint256$_$vec$u8$_vec$u8$_address_A2_U256_U256$_from_memory(headStart, dataEnd) -> value_0, value_1, value_2, value_3 {
            if slt(sub(dataEnd, headStart), 128) { $Abort(96) }
            {
                let offset := mload(add(headStart, 0))
                if gt(offset, 0xffffffffffffffff) { $Abort(96) }
                value_0 := abi_decode_string_vec$u8$_from_memory(add(headStart, offset), dataEnd)
            }
            {
                let offset := mload(add(headStart, 32))
                if gt(offset, 0xffffffffffffffff) { $Abort(96) }
                value_1 := abi_decode_string_vec$u8$_from_memory(add(headStart, offset), dataEnd)
            }
            {
                let offset := 64
                value_2 := abi_decode_address_from_memory(add(headStart, offset), dataEnd)
            }
            {
                let offset := 96
                value_3 := abi_decode_uint256_from_memory(add(headStart, offset), dataEnd)
            }
        }
        function abi_decode_uint256_from_memory(offset, end) -> value {
            value := mload(offset)
            validator_uint256(value)
        }
        function validator_uint256(value) {
            if iszero(eq(value, cleanup_uint256(value))) { $Abort(95) }
        }
        function abi_decode_address_from_memory(offset, end) -> value {
            value := mload(offset)
            validator_address(value)
        }
        function validator_address(value) {
            if iszero(eq(value, cleanup_address(value))) { $Abort(95) }
        }
        function cleanup_address(value) -> cleaned {
            cleaned := and(value, 0xffffffffffffffffffffffffffffffffffffffff)
        }
        function abi_decode_string_vec$u8$_from_memory(offset, end) -> array {
            if iszero(slt(add(offset, 0x1f), end)) { $Abort(94) }
            let length := mload(offset)
            let size := add(mul(1, length), 32)
            array := abi_decode_available_length__string_from_memory(add(offset, 0x20), length, size, end)
        }
        function abi_decode_available_length__string_from_memory(src, length, size, end) -> array {
            array := $Malloc($CheckMemorySize(size))
            $MemoryStoreU64(array, length)
            $MemoryStoreU64(add(array, 8), length)
            let dst := add(array, 32)
            if gt(add(src, sub(size, 32)), end) { $Abort(93) }
            $CopyFromMemoryToMemory(src, dst, length)
        }
        function $Abort(code) {
            mstore(0, code)
            revert(24, 8) // TODO: store code as a string?
        }
        function $AbortBuiltin() {
            $Abort(sub(0, 1))
        }
        function $Malloc(size) -> offs {
            offs := mload(0)
            // pad to word size
            mstore(0, add(offs, shl(5, shr(5, add(size, 31)))))
        }
        function $Free(offs, size) {
        }
        function $MakePtr(is_storage, offs) -> ptr {
          ptr := or(is_storage, shl(1, offs))
        }
        function $IsStoragePtr(ptr) -> b {
          b := and(ptr, 0x1)
        }
        function $OffsetPtr(ptr) -> offs {
          offs := shr(1, ptr)
        }
        function $MaskForSize(size) -> mask {
          mask := sub(shl(shl(3, size), 1), 1)
        }
        function $ExtractBytes(word, start, size) -> bytes {
           switch size
           case 1 {
              // use the faster byte primitive
              bytes := byte(start, word)
           }
           default {
              // As we have big endian, we need to right shift the value from
              // where the highest byte starts in the word (32 - start), minus
              // the size.
              let shift_bits := shl(3, sub(sub(32, start), size))
              bytes := and(shr(shift_bits, word), $MaskForSize(size))
           }
        }
        function $InjectBytes(word, start, size, bytes) -> new_word {
           let shift_bits := shl(3, sub(sub(32, start), size))
           // Blend out the bits which we inject
           let neg_mask := not(shl(shift_bits, $MaskForSize(size)))
           word := and(word, neg_mask)
           // Overlay the bits we inject
           new_word := or(word, shl(shift_bits, bytes))
        }
        function $ToWordOffs(offs) -> word_offs, byte_offset {
          word_offs := shr(5, offs)
          byte_offset := and(offs, 0x1F)
        }
        function $OverflowBytes(byte_offset, size) -> overflow_bytes {
          let available_bytes := sub(32, byte_offset)
          switch gt(size, available_bytes)
          case 0 {
            overflow_bytes := 0
          }
          default {
            overflow_bytes := sub(size, available_bytes)
          }
        }
        function $MemoryLoadBytes(offs, size) -> val {
          // Lower bit where the value in the higher bytes ends
          let bit_end := shl(3, sub(32, size))
          val := shr(bit_end, mload(offs))
        }
        function $MemoryStoreBytes(offs, size, val) {
          let bit_end := shl(3, sub(32, size))
          let mask := shl(bit_end, $MaskForSize(size))
          mstore(offs, or(and(mload(offs), not(mask)), shl(bit_end, val)))
        }
        function $StorageLoadBytes(offs, size) -> val {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          val := $ExtractBytes(sload(key), byte_offs, size)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          if $LogicalNot(iszero(overflow_bytes)) {
            key := $StorageKey(0, add(word_offs, 1))
            let extra_bytes := $ExtractBytes(sload(key), 0, overflow_bytes)
            val := or(shl(shl(3, overflow_bytes), val), extra_bytes)
          }
        }
        function $StorageStoreBytes(offs, size, bytes) {
          let word_offs, byte_offs := $ToWordOffs(offs)
          let key := $StorageKey(0, word_offs)
          let overflow_bytes := $OverflowBytes(byte_offs, size)
          switch overflow_bytes
          case 0 {
            sstore(key, $InjectBytes(sload(key), byte_offs, size, bytes))
          }
          default {
            // Shift the higher bytes to the right
            let used_bytes := sub(size, overflow_bytes)
            let higher_bytes := shr(used_bytes, bytes)
            let lower_bytes := and(bytes, $MaskForSize(overflow_bytes))
            sstore(key, $InjectBytes(sload(key), byte_offs, used_bytes, higher_bytes))
            key := $StorageKey(0, add(word_offs, 1))
            sstore(key, $InjectBytes(sload(key), 0, overflow_bytes, lower_bytes))
          }
        }
        function $StorageKey(group, word) -> key {
          mstore(32, word)
          mstore(64, shl(224, group))
          key := keccak256(32, 36)
          //let mask := sub(shl(shl(3, 28), 1), 1)
          //let masked_word := and(word, mask)
          //key := or(shl(224, group), masked_word)
        }
        function $MakeTypeStorageBase(category, type_hash, id) -> offs {
          offs := or(shl(252, category), or(shl(220, type_hash), shl(60, id)))
        }
        function $NewLinkedStorageBase(type_hash) -> offs {
          let key := $StorageKey(1, 1)
          let handle := sload(key)
          sstore(key, add(handle, 1))
          offs := $MakeTypeStorageBase(1, type_hash, handle)
        }
        function $IndexPtr(ptr, offs) -> new_ptr {
          new_ptr := $MakePtr($IsStoragePtr(ptr), add($OffsetPtr(ptr), offs))
        }
        function $NewTableHandle() -> handle {
          let key := $StorageKey(1, 0)
          handle := sload(key)
          if iszero(handle) {
             // no tables have been allocated in this contract, need to initialize the counter
             // to the number of storage groups already statically allocated
             handle := 2
          }
          sstore(key, add(handle, 1))
        }

        function $MemoryStoreU8(offs, val) {
          // Shortcut via special instruction
          mstore8(offs, val)
        }
        function $MemoryLoadU64(offs) -> val {
          val := $MemoryLoadBytes(offs, 8)
        }
        function $MemoryStoreU64(offs, val) {
          $MemoryStoreBytes(offs, 8, val)
        }
        function $LoadU256(ptr) -> val {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            val := $MemoryLoadU256(offs)
          }
          default {
            val := $StorageLoadU256(offs)
          }
        }
        function $MemoryLoadU256(offs) -> val {
          val := $MemoryLoadBytes(offs, 32)
        }
        function $StorageLoadU256(offs) -> val {
          val := $StorageLoadBytes(offs, 32)
        }
        function $StoreU256(ptr, val) {
          let offs := $OffsetPtr(ptr)
          switch $IsStoragePtr(ptr)
          case 0 {
            $MemoryStoreU256(offs, val)
          }
          default {
            $StorageStoreU256(offs, val)
          }
        }
        function $MemoryStoreU256(offs, val) {
          $MemoryStoreBytes(offs, 32, val)
        }
        function $StorageStoreU256(offs, val) {
          $StorageStoreBytes(offs, 32, val)
        }
        function $AlignedStorageLoad(offs) -> val {
          let word_offs := shr(5, offs)
          val := sload($StorageKey(0, word_offs))
        }
        function $AlignedStorageStore(offs, val) {
          let word_offs := shr(5, offs)
          sstore($StorageKey(0, word_offs), val)
        }
        function $CopyMemoryU8(src, dst, size) {
          let i := 0
          for { } lt(i, size) { i := add(i, 32) } {
            mstore(add(dst, i), mload(add(src, i)))
          }
          if gt(i, size)
          {
              for {let j := i} lt(j, size) {j := add(j, 1)} {
                mstore8(add(dst, j), 0)
              }
          }
        }
        function $CheckMemorySize(len) -> checked_len {
            if gt(len, 0xffffffffffffffff) { $AbortBuiltin() }
            checked_len := len
        }
        function $CopyFromMemoryToMemory(src, dst, length) {
          let i := 0
          for { } lt(i, length) { i := add(i, 32) }
          {
            mstore(add(dst, i), mload(add(src, i)))
          }
          if gt(i, length)
          {
            // clear end
            mstore(add(dst, length), 0)
          }
        }
        function $AddU256(x, y) -> r {
            if lt(sub(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, x), y) { $AbortBuiltin() }
            r := add(x, y)
        }
        function $Neq(x, y) -> r {
            r := $LogicalNot(eq(x, y))
        }
        function $LogicalNot(x) -> r {
            r := iszero(x)
        }
        function $ClosestGreaterPowerOfTwo(x) -> r {
            r := or(r, shr(1, x))
            r := or(r, shr(2, r))
            r := or(r, shr(4, r))
            r := or(r, shr(8, r))
            r := or(r, shr(16, r))
            r := or(r, shr(32, r))
            r := add(x, 1)
        }
        function $RoundUp(value) -> result {
            result := and(add(value, 31), not(31))
        }
    }
    object "A2_ERC20Mock_deployed" {
        code {
            mstore(0, memoryguard(160))
            if iszero(lt(calldatasize(), 4))
            {
                let selector := $Shr(calldataload(0), 224)
                switch selector
                case 0xa9059cbb
                {
                    // transfer(address,uint256)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1 := abi_decode_tuple_$address_uint256$_$address_A2_U256_U256$(4, calldatasize())
                    let ret_0 := A2_ERC20Mock_transfer(param_0, param_1)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$bool$_$bool$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0xdd62ed3e
                {
                    // allowance(address,address)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1 := abi_decode_tuple_$address_address$_$address_address$(4, calldatasize())
                    let ret_0 := A2_ERC20Mock_allowance(param_0, param_1)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$uint256$_$A2_U256_U256$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x095ea7b3
                {
                    // approve(address,uint256)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1 := abi_decode_tuple_$address_uint256$_$address_A2_U256_U256$(4, calldatasize())
                    let ret_0 := A2_ERC20Mock_approve(param_0, param_1)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$bool$_$bool$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x56189cb4
                {
                    // approveInternal(address,address,uint256)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1, param_2 := abi_decode_tuple_$address_address_uint256$_$address_address_A2_U256_U256$(4, calldatasize())
                    A2_ERC20Mock_approveInternal(param_0, param_1, param_2)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple__(memPos)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x70a08231
                {
                    // balanceOf(address)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0 := abi_decode_tuple_$address$_$address$(4, calldatasize())
                    let ret_0 := A2_ERC20Mock_balanceOf(param_0)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$uint256$_$A2_U256_U256$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x9dc29fac
                {
                    // burn(address,uint256)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1 := abi_decode_tuple_$address_uint256$_$address_A2_U256_U256$(4, calldatasize())
                    A2_ERC20Mock_burn(param_0, param_1)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple__(memPos)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x06fdde03
                {
                    // name()
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let ret_0 := A2_ERC20Mock_name()
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$string$_$vec$u8$$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x95d89b41
                {
                    // symbol()
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let ret_0 := A2_ERC20Mock_symbol()
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$string$_$vec$u8$$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x313ce567
                {
                    // decimals()
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let ret_0 := A2_ERC20Mock_decimals()
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$uint8$_$u8$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0xa457c2d7
                {
                    // decreaseAllowance(address,uint256)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1 := abi_decode_tuple_$address_uint256$_$address_A2_U256_U256$(4, calldatasize())
                    let ret_0 := A2_ERC20Mock_decreaseAllowance(param_0, param_1)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$bool$_$bool$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x39509351
                {
                    // increaseAllowance(address,uint256)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1 := abi_decode_tuple_$address_uint256$_$address_A2_U256_U256$(4, calldatasize())
                    let ret_0 := A2_ERC20Mock_increaseAllowance(param_0, param_1)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$bool$_$bool$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x40c10f19
                {
                    // mint(address,uint256)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1 := abi_decode_tuple_$address_uint256$_$address_A2_U256_U256$(4, calldatasize())
                    A2_ERC20Mock_mint(param_0, param_1)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple__(memPos)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x18160ddd
                {
                    // totalSupply()
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let ret_0 := A2_ERC20Mock_totalSupply()
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$uint256$_$A2_U256_U256$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x23b872dd
                {
                    // transferFrom(address,address,uint256)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1, param_2 := abi_decode_tuple_$address_address_uint256$_$address_address_A2_U256_U256$(4, calldatasize())
                    let ret_0 := A2_ERC20Mock_transferFrom(param_0, param_1, param_2)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple_$bool$_$bool$(memPos, ret_0)
                    return(memPos, sub(memEnd, memPos))
                }
                case 0x222f5be0
                {
                    // transferInternal(address,address,uint256)
                    if callvalue()
                    {
                        $Abort(99)
                    }
                    let param_0, param_1, param_2 := abi_decode_tuple_$address_address_uint256$_$address_address_A2_U256_U256$(4, calldatasize())
                    A2_ERC20Mock_transferInternal(param_0, param_1, param_2)
                    let memPos := mload(0)
                    let memEnd := abi_encode_tuple__(memPos)
                    return(memPos, sub(memEnd, memPos))
                }
                default {}
            }
            $Abort(97)
            function A2_ERC20Mock_transfer(to, amount) -> $result {
                let $t2, $t3
                // $t2 := Evm::sender()
                /// @src 1:3842:3850
                $t2 := A2_Evm_sender()
                // ERC20Mock::transfer_($t2, $t0, $t1)
                /// @src 1:3832:3863
                A2_ERC20Mock_transfer_($t2, to, amount)
                // $t3 := true
                /// @src 1:3873:3877
                $t3 := true
                // return $t3
                /// @src 1:3873:3877
                $result := $t3
            }

            function A2_ERC20Mock_allowance(owner, spender) -> $result {
                let s, $t3, $t4, $t5, $t6
                // $t3 := Evm::self()
                /// @src 1:4877:4883
                $t3 := A2_Evm_self()
                // $t4 := borrow_global<ERC20Mock::State>($t3)
                /// @src 1:4852:4869
                {
                    let $base_offset := $MakeTypeStorageBase(0, 0xa937cc63, $t3)
                    if iszero($AlignedStorageLoad($base_offset)) {
                      $AbortBuiltin()
                    }
                    $t4 := $MakePtr(true, add($base_offset, 32))
                }
                // $t5 := ERC20Mock::mut_allowance($t4, $t0, $t1)
                /// @src 1:4895:4927
                $t5 := A2_ERC20Mock_mut_allowance($t4, owner, spender)
                // $t6 := read_ref($t5)
                /// @src 1:4894:4927
                $t6 := $LoadU256($t5)
                // return $t6
                /// @src 1:4894:4927
                $result := $t6
            }

            function A2_ERC20Mock_approve(spender, amount) -> $result {
                let $t2, $t3
                // $t2 := Evm::sender()
                /// @src 1:4548:4556
                $t2 := A2_Evm_sender()
                // ERC20Mock::approve_($t2, $t0, $t1)
                /// @src 1:4539:4574
                A2_ERC20Mock_approve_($t2, spender, amount)
                // $t3 := true
                /// @src 1:4584:4588
                $t3 := true
                // return $t3
                /// @src 1:4584:4588
                $result := $t3
            }

            function A2_ERC20Mock_approveInternal(owner, spender, value) {
                // ERC20Mock::approve_($t0, $t1, $t2)
                /// @src 1:1664:1695
                A2_ERC20Mock_approve_(owner, spender, value)
                // return ()
                /// @src 1:1664:1695
            }

            function A2_ERC20Mock_balanceOf(owner) -> $result {
                let s, $t2, $t3, $t4, $t5
                // $t2 := Evm::self()
                /// @src 1:3561:3567
                $t2 := A2_Evm_self()
                // $t3 := borrow_global<ERC20Mock::State>($t2)
                /// @src 1:3536:3553
                {
                    let $base_offset := $MakeTypeStorageBase(0, 0xa937cc63, $t2)
                    if iszero($AlignedStorageLoad($base_offset)) {
                      $AbortBuiltin()
                    }
                    $t3 := $MakePtr(true, add($base_offset, 32))
                }
                // $t4 := ERC20Mock::mut_balanceOf($t3, $t0)
                /// @src 1:3579:3602
                $t4 := A2_ERC20Mock_mut_balanceOf($t3, owner)
                // $t5 := read_ref($t4)
                /// @src 1:3578:3602
                $t5 := $LoadU256($t4)
                // return $t5
                /// @src 1:3578:3602
                $result := $t5
            }

            function A2_ERC20Mock_burn(account, amount) {
                // ERC20Mock::burn_($t0, $t1)
                /// @src 1:1268:1290
                A2_ERC20Mock_burn_(account, amount)
                // return ()
                /// @src 1:1268:1290
            }

            function A2_ERC20Mock_name() -> $result {
                let $t0, $t1, $t2, $t3
                // $t0 := Evm::self()
                /// @src 1:2681:2687
                $t0 := A2_Evm_self()
                // $t1 := borrow_global<ERC20Mock::State>($t0)
                /// @src 1:2660:2673
                {
                    let $base_offset := $MakeTypeStorageBase(0, 0xa937cc63, $t0)
                    if iszero($AlignedStorageLoad($base_offset)) {
                      $AbortBuiltin()
                    }
                    $t1 := $MakePtr(true, add($base_offset, 32))
                }
                // $t2 := borrow_field<ERC20Mock::State>.name($t1)
                /// @src 1:2659:2693
                $t2 := $t1
                // $t3 := read_ref($t2)
                /// @src 1:2658:2693
                $t3 := $LoadU256($t2)
                if $IsStoragePtr($t2){
                    let $storage_ptr_2300595445
                    let $size_2300595445 := $StorageLoadU64($t3)
                    let $capacity_2300595445 := $ClosestGreaterPowerOfTwo($size_2300595445)
                    $storage_ptr_2300595445 := $Malloc(add(32, mul($capacity_2300595445, 1)))
                    let $data_size_2300595445 := mul($size_2300595445, 1)
                    mstore($storage_ptr_2300595445, $AlignedStorageLoad($t3))
                    $MemoryStoreU64(add($storage_ptr_2300595445, 8), $capacity_2300595445)
                    let $data_src_2300595445 := add($t3, 32)
                    let $data_dst_2300595445 := add($storage_ptr_2300595445, 32)
                    for { let $offs_2300595445 := 0 } lt($offs_2300595445, $data_size_2300595445) { $offs_2300595445 := add($offs_2300595445, 32)} {
                        mstore(add($data_dst_2300595445, $offs_2300595445), $AlignedStorageLoad(add($data_src_2300595445, $offs_2300595445)))
                    }
                    $t3 := $storage_ptr_2300595445
                }
                // return $t3
                /// @src 1:2658:2693
                $result := $t3
            }

            function A2_ERC20Mock_symbol() -> $result {
                let $t0, $t1, $t2, $t3
                // $t0 := Evm::self()
                /// @src 1:2921:2927
                $t0 := A2_Evm_self()
                // $t1 := borrow_global<ERC20Mock::State>($t0)
                /// @src 1:2900:2913
                {
                    let $base_offset := $MakeTypeStorageBase(0, 0xa937cc63, $t0)
                    if iszero($AlignedStorageLoad($base_offset)) {
                      $AbortBuiltin()
                    }
                    $t1 := $MakePtr(true, add($base_offset, 32))
                }
                // $t2 := borrow_field<ERC20Mock::State>.symbol($t1)
                /// @src 1:2899:2935
                $t2 := $IndexPtr($t1, 32)
                // $t3 := read_ref($t2)
                /// @src 1:2898:2935
                $t3 := $LoadU256($t2)
                if $IsStoragePtr($t2){
                    let $storage_ptr_2300595445
                    let $size_2300595445 := $StorageLoadU64($t3)
                    let $capacity_2300595445 := $ClosestGreaterPowerOfTwo($size_2300595445)
                    $storage_ptr_2300595445 := $Malloc(add(32, mul($capacity_2300595445, 1)))
                    let $data_size_2300595445 := mul($size_2300595445, 1)
                    mstore($storage_ptr_2300595445, $AlignedStorageLoad($t3))
                    $MemoryStoreU64(add($storage_ptr_2300595445, 8), $capacity_2300595445)
                    let $data_src_2300595445 := add($t3, 32)
                    let $data_dst_2300595445 := add($storage_ptr_2300595445, 32)
                    for { let $offs_2300595445 := 0 } lt($offs_2300595445, $data_size_2300595445) { $offs_2300595445 := add($offs_2300595445, 32)} {
                        mstore(add($data_dst_2300595445, $offs_2300595445), $AlignedStorageLoad(add($data_src_2300595445, $offs_2300595445)))
                    }
                    $t3 := $storage_ptr_2300595445
                }
                // return $t3
                /// @src 1:2898:2935
                $result := $t3
            }

            function A2_ERC20Mock_decimals() -> $result {
                let $t0
                // $t0 := 18
                /// @src 1:3116:3118
                $t0 := 18
                // return $t0
                /// @src 1:3116:3118
                $result := $t0
            }

            function A2_ERC20Mock_decreaseAllowance(spender, subtractedValue) -> $result {
                let currentAllowance, owner, $t4, $t5, $t6, $t7, $t8, $t9
                // $t4 := Evm::sender()
                /// @src 1:5584:5592
                $t4 := A2_Evm_sender()
                // $t5 := ERC20Mock::allowance($t4, $t0)
                /// @src 1:5625:5650
                $t5 := A2_ERC20Mock_allowance($t4, spender)
                // $t6 := >=($t5, $t1)
                /// @src 1:5668:5711
                $t6 := $GtEq($t5, subtractedValue)
                // $t7 := [69, 82, 67, 50, 48, 58, 32, 100, 101, 99, 114, 101, 97, 115, 101, 100, 32, 97, 108, 108, 111, 119, 97, 110, 99, 101, 32, 98, 101, 108, 111, 119, 32, 122, 101, 114, 111]
                /// @src 1:5713:5753
                $t7 := $Malloc(69)
                $MemoryStoreU64($t7, 37)
                $MemoryStoreU64(add($t7, 8), $ClosestGreaterPowerOfTwo(69))
                let $offs_4151751928 := add($t7, 32)
                $MemoryStoreU8($offs_4151751928, 69)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 82)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 67)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 50)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 48)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 58)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 32)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 100)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 101)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 99)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 114)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 101)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 97)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 115)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 101)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 100)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 32)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 97)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 108)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 108)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 111)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 119)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 97)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 110)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 99)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 101)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 32)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 98)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 101)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 108)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 111)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 119)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 32)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 122)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 101)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 114)
                $offs_4151751928 := add($offs_4151751928, 1)
                $MemoryStoreU8($offs_4151751928, 111)
                $offs_4151751928 := add($offs_4151751928, 1)
                // Evm::require($t6, $t7)
                /// @src 1:5660:5754
                A2_Evm_require($t6, $t7)
                // $t8 := -($t5, $t1)
                /// @src 1:5789:5833
                $t8 := $Sub($t5, subtractedValue)
                // ERC20Mock::approve_($t4, $t0, $t8)
                /// @src 1:5764:5834
                A2_ERC20Mock_approve_($t4, spender, $t8)
                // $t9 := true
                /// @src 1:5844:5848
                $t9 := true
                // return $t9
                /// @src 1:5844:5848
                $result := $t9
            }

            function A2_ERC20Mock_increaseAllowance(spender, addedValue) -> $result {
                let owner, $t3, $t4, $t5, $t6
                // $t3 := Evm::sender()
                /// @src 1:5200:5208
                $t3 := A2_Evm_sender()
                // $t4 := ERC20Mock::allowance($t3, $t0)
                /// @src 1:5253:5278
                $t4 := A2_ERC20Mock_allowance($t3, spender)
                // $t5 := +($t4, $t1)
                /// @src 1:5243:5291
                $t5 := $AddU256($t4, addedValue)
                // ERC20Mock::approve_($t3, $t0, $t5)
                /// @src 1:5218:5292
                A2_ERC20Mock_approve_($t3, spender, $t5)
                // $t6 := true
                /// @src 1:5302:5306
                $t6 := true
                // return $t6
                /// @src 1:5302:5306
                $result := $t6
            }

            function A2_ERC20Mock_mint(account, amount) {
                // ERC20Mock::mint_($t0, $t1)
                /// @src 1:1115:1137
                A2_ERC20Mock_mint_(account, amount)
                // return ()
                /// @src 1:1115:1137
            }

            function A2_ERC20Mock_totalSupply() -> $result {
                let $t0, $t1, $t2, $t3
                // $t0 := Evm::self()
                /// @src 1:3318:3324
                $t0 := A2_Evm_self()
                // $t1 := borrow_global<ERC20Mock::State>($t0)
                /// @src 1:3297:3310
                {
                    let $base_offset := $MakeTypeStorageBase(0, 0xa937cc63, $t0)
                    if iszero($AlignedStorageLoad($base_offset)) {
                      $AbortBuiltin()
                    }
                    $t1 := $MakePtr(true, add($base_offset, 32))
                }
                // $t2 := borrow_field<ERC20Mock::State>.total_supply($t1)
                /// @src 1:3296:3338
                $t2 := $IndexPtr($t1, 128)
                // $t3 := read_ref($t2)
                /// @src 1:3295:3338
                $t3 := $LoadU256($t2)
                // return $t3
                /// @src 1:3295:3338
                $result := $t3
            }

            function A2_ERC20Mock_transferFrom(from, to, amount) -> $result {
                let $t3, $t4
                // $t3 := Evm::sender()
                /// @src 1:4218:4226
                $t3 := A2_Evm_sender()
                // ERC20Mock::spendAllowance_($t0, $t3, $t2)
                /// @src 1:4196:4235
                A2_ERC20Mock_spendAllowance_(from, $t3, amount)
                // ERC20Mock::transfer_($t0, $t1, $t2)
                /// @src 1:4245:4272
                A2_ERC20Mock_transfer_(from, to, amount)
                // $t4 := true
                /// @src 1:4282:4286
                $t4 := true
                // return $t4
                /// @src 1:4282:4286
                $result := $t4
            }

            function A2_ERC20Mock_transferInternal(from, to, value) {
                // ERC20Mock::transfer_($t0, $t1, $t2)
                /// @src 1:1462:1488
                A2_ERC20Mock_transfer_(from, to, value)
                // return ()
                /// @src 1:1462:1488
            }

            function A2_ERC20Mock_transfer_(from, to, amount) {
                let from_bal, from_bal_val, s, to_bal, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23
                // $t7 := 0x0
                /// @src 1:7263:7267
                $t7 := 0x0
                // $t8 := !=($t0, $t7)
                /// @src 1:7260:7262
                $t8 := $Neq(from, $t7)
                // $t9 := [69, 82, 67, 50, 48, 58, 32, 116, 114, 97, 110, 115, 102, 101, 114, 32, 102, 114, 111, 109, 32, 116, 104, 101, 32, 122, 101, 114, 111, 32, 97, 100, 100, 114, 101, 115, 115]
                /// @src 1:7269:7309
                $t9 := $Malloc(69)
                $MemoryStoreU64($t9, 37)
                $MemoryStoreU64(add($t9, 8), $ClosestGreaterPowerOfTwo(69))
                let $offs_1455811770 := add($t9, 32)
                $MemoryStoreU8($offs_1455811770, 69)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 82)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 67)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 50)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 48)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 58)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 32)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 116)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 114)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 97)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 110)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 115)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 102)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 101)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 114)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 32)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 102)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 114)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 111)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 109)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 32)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 116)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 104)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 101)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 32)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 122)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 101)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 114)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 111)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 32)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 97)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 100)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 100)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 114)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 101)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 115)
                $offs_1455811770 := add($offs_1455811770, 1)
                $MemoryStoreU8($offs_1455811770, 115)
                $offs_1455811770 := add($offs_1455811770, 1)
                // Evm::require($t8, $t9)
                /// @src 1:7247:7310
                A2_Evm_require($t8, $t9)
                // $t10 := 0x0
                /// @src 1:7334:7338
                $t10 := 0x0
                // $t11 := !=($t1, $t10)
                /// @src 1:7331:7333
                $t11 := $Neq(to, $t10)
                // $t12 := [69, 82, 67, 50, 48, 58, 32, 116, 114, 97, 110, 115, 102, 101, 114, 32, 116, 111, 32, 116, 104, 101, 32, 122, 101, 114, 111, 32, 97, 100, 100, 114, 101, 115, 115]
                /// @src 1:7340:7378
                $t12 := $Malloc(67)
                $MemoryStoreU64($t12, 35)
                $MemoryStoreU64(add($t12, 8), $ClosestGreaterPowerOfTwo(67))

                let $offs_283268869 := add($t12, 32)
                $MemoryStoreU8($offs_283268869, 69)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 82)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 67)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 50)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 48)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 58)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 32)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 116)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 114)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 97)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 110)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 115)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 102)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 101)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 114)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 32)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 116)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 111)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 32)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 116)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 104)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 101)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 32)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 122)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 101)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 114)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 111)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 32)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 97)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 100)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 100)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 114)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 101)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 115)
                $offs_283268869 := add($offs_283268869, 1)
                $MemoryStoreU8($offs_283268869, 115)
                $offs_283268869 := add($offs_283268869, 1)

                // Evm::require($t11, $t12)
                /// @src 1:7320:7379
                A2_Evm_require($t11, $t12)
                // $t13 := Evm::self()
                /// @src 1:7422:7428
                $t13 := A2_Evm_self()
                // $t14 := borrow_global<ERC20Mock::State>($t13)
                /// @src 1:7397:7414
                {
                    let $base_offset := $MakeTypeStorageBase(0, 0xa937cc63, $t13)
                    if iszero($AlignedStorageLoad($base_offset)) {
                      $AbortBuiltin()
                    }
                    $t14 := $MakePtr(true, add($base_offset, 32))
                }
                // $t15 := ERC20Mock::mut_balanceOf($t14, $t0)
                /// @src 1:7454:7476
                $t15 := A2_ERC20Mock_mut_balanceOf($t14, from)
                // $t16 := read_ref($t15)
                /// @src 1:7505:7514
                $t16 := $LoadU256($t15)
                // $t17 := <=($t2, $t16)
                /// @src 1:7532:7567
                $t17 := $LtEq(amount, $t16)
                // $t18 := [69, 82, 67, 50, 48, 58, 32, 116, 114, 97, 110, 115, 102, 101, 114, 32, 97, 109, 111, 117, 110, 116, 32, 101, 120, 99, 101, 101, 100, 115, 32, 98, 97, 108, 97, 110, 99, 101]
                /// @src 1:7569:7610
                $t18 := $Malloc(70)
                $MemoryStoreU64($t18, 38)
                $MemoryStoreU64(add($t18, 8), $ClosestGreaterPowerOfTwo(70))

                let $offs_2833778497 := add($t18, 32)
                $MemoryStoreU8($offs_2833778497, 69)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 82)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 67)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 50)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 48)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 58)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 32)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 116)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 114)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 97)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 110)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 115)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 102)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 101)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 114)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 32)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 97)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 109)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 111)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 117)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 110)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 116)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 32)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 101)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 120)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 99)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 101)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 101)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 100)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 115)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 32)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 98)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 97)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 108)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 97)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 110)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 99)
                $offs_2833778497 := add($offs_2833778497, 1)
                $MemoryStoreU8($offs_2833778497, 101)
                $offs_2833778497 := add($offs_2833778497, 1)

                // Evm::require($t17, $t18)
                /// @src 1:7524:7611
                A2_Evm_require($t17, $t18)
                // $t19 := -($t16, $t2)
                /// @src 1:7633:7669
                $t19 := $Sub($t16, amount)
                // write_ref($t15, $t19)
                /// @src 1:7621:7669
                $StoreU256($t15, $t19)
                // $t20 := ERC20Mock::mut_balanceOf($t14, $t1)
                /// @src 1:7692:7712
                $t20 := A2_ERC20Mock_mut_balanceOf($t14, to)
                // $t21 := read_ref($t20)
                /// @src 1:7778:7785
                $t21 := $LoadU256($t20)
                // $t22 := +($t21, $t2)
                /// @src 1:7768:7799
                $t22 := $AddU256($t21, amount)
                // write_ref($t20, $t22)
                /// @src 1:7758:7799
                $StoreU256($t20, $t22)
                // $t23 := pack ERC20Mock::Transfer($t0, $t1, $t2)
                /// @src 1:7814:7847
                {
                    let $mem := $Malloc(96)
                    $MemoryStoreU256(add($mem, 0), from)
                    $MemoryStoreU256(add($mem, 32), to)
                    $MemoryStoreU256(add($mem, 64), amount)
                    $t23 := $mem
                }
                // Evm::emit<ERC20Mock::Transfer>($t23)
                /// @src 1:7809:7848
                A2_Evm_emit$A2_ERC20Mock_Transfer$($t23)
                // return ()
                /// @src 1:7848:7849
            }

            function A2_Evm_emit$A2_ERC20Mock_Transfer$(e) {
                let $t1 := 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
                let $t2 := $MemoryLoadU256(add(e, 0))
                let $t3 := $MemoryLoadU256(add(e, 32))
                let $t4 := $MemoryLoadU256(add(e, 64))
                {
                    let $t5 := mload(0)
                    let $t6 := abi_encode_tuple_$uint256$_$A2_U256_U256$($t5, $t4)
                    log3($t5, sub($t6, $t5), $t1,$t2,$t3)
                }
            }
            function A2_ERC20Mock_mut_balanceOf(s, owner) -> $result {
                let $t2, $t3, $t4, $t5
                let $locals := $Malloc(32)
                // mstore($locals, owner)
                // $t2 := borrow_field<ERC20Mock::State>.balances($t0)
                /// @src 1:8504:8519
                $t2 := $IndexPtr(s, 64)
                // $t3 := borrow_local($t1)
                /// @src 1:8521:8527
                // $t3 := $MakePtr(false, $locals)
                // $t4 := U256::zero()
                /// @src 1:8529:8541
                $t4 := A2_U256_zero()
                // $t5 := Table::borrow_mut_with_default<address, U256::U256>($t2, $t3, $t4)
                /// @src 1:8473:8542
                $t5 := A2_Table_borrow_mut_with_default$address_A2_U256_U256$($t2, owner, $t4)
                // return $t5
                /// @src 1:8473:8542
                $result := $t5
                $Free($locals, 32)
            }

            function A2_Table_borrow_mut_with_default$address_A2_U256_U256$(table, key, default_value) -> $result {
                let tmp_$3, tmp_$4, $t5, $t6, $t7, $t8
                let $block := 4
                for {} true {} {
                    switch $block
                    case 2 {
                        // label L0
                        // Table::insert<#0, #1>($t0, $t1, $t2)
                        /// @src 3:903:936
                        A2_Table_insert$address_A2_U256_U256$(table, key, default_value)
                        // goto L2
                        /// @src 3:967:972
                        $block := 3
                    }
                    case 3 {
                        // label L2
                        // $t8 := Table::borrow_mut<#0, #1>($t0, $t1)
                        /// @src 3:956:978
                        $t8 := A2_Table_borrow_mut$address_A2_U256_U256$(table, key)
                        // return $t8
                        /// @src 3:956:978
                        $result := $t8
                        leave
                    }
                    case 4 {
                        // $t5 := freeze_ref($t0)
                        /// @src 3:875:887
                        $t5 := table
                        // $t6 := Table::contains<#0, #1>($t5, $t1)
                        /// @src 3:867:887
                        // $t6 := A2_Table_contains$address_A2_U256_U256$($t5, key)
                        // $t7 := !($t6)
                        /// @src 3:866:867
                        $t7 := $LogicalNot(true)
                        // if ($t7) goto L0 else goto L2
                        /// @src 3:862:946
                        switch $t7
                        case 0  { $block := 3 }
                        default { $block := 2 }
                    }
                }
            }

            function A2_Table_contains$address_A2_U256_U256$(table_ref, key) -> res {
                // let key := $LoadU256(key_ref)
                let table_handle := 2
                let storage_key := $StorageKey(table_handle, key)
                let word := sload(storage_key)
                res := $LogicalNot(iszero(word))
            }
            function A2_Table_borrow_mut$address_A2_U256_U256$(table_ref, key) -> value_ref {
                // let key := $LoadU256(key_ref)
                let table_handle := 2
                let storage_key := $StorageKey(table_handle, key)
                let value_offs := sload(storage_key)
                if iszero(value_offs) {
                  // $AbortBuiltin()
                }
                value_ref := $MakePtr(true, value_offs)
            }
            function A2_Table_insert$address_A2_U256_U256$(table_ref, key, value) {
                // let key := $LoadU256(key_ref)
                let table_handle := 2
                let storage_key := $StorageKey(table_handle, key)
                let word := sload(storage_key)
                if $LogicalNot(iszero(word)) {
                  // $AbortBuiltin()
                }
                let $linked_dst_2934085429 := $NewLinkedStorageBase(0xaee29735)
                $StorageStoreU256($linked_dst_2934085429, value)
                sstore(storage_key, value)
            }
            function A2_U256_zero() -> $result {
                let $t0
                // $t0 := 0
                /// @src 2:991:1012
                $t0 := 0
                // return $t0
                /// @src 2:991:1012
                $result := $t0
            }

            function A2_Evm_require(cond, message) {
                let $t2
                let $block := 4
                for {} true {} {
                    switch $block
                    case 2 {
                        // label L0
                        // Evm::abort_with($t1)
                        /// @src 4:2825:2844
                        A2_Evm_abort_with(message)
                        // goto L2
                        /// @src 4:2812:2847
                        $block := 3
                    }
                    case 3 {
                        // label L2
                        // return ()
                        /// @src 4:2812:2847
                        leave
                    }
                    case 4 {
                        // $t2 := !($t0)
                        /// @src 4:2816:2817
                        $t2 := $LogicalNot(cond)
                        // if ($t2) goto L0 else goto L2
                        /// @src 4:2812:2847
                        switch $t2
                        case 0  { $block := 3 }
                        default { $block := 2 }
                    }
                }
            }

            function A2_Evm_abort_with(message) {
              let head := $Malloc(32)
              // store the function selector for Error(string)
              mstore(head, 3963877391197344453575983046348115674221700746820753546331534351508065746944)
              let pos := add(head, 4)
              mstore(pos, 32)
              pos := add(pos, 32)
              let size := $MemoryLoadU64(message)
              mstore(pos, size)
              pos := add(pos, 32)
              $CopyMemoryU8(add(message, 32), pos, size)
              size := $RoundUp(size)
              let end := add(pos, size)
              revert(head, sub(end, head))
            }
            function A2_Evm_self() -> addr {
              addr := address()
            }
            function A2_ERC20Mock_spendAllowance_(owner, spender, amount) {
                let currentAllowance, $t4, $t5, $t6, $t7, $t8, $t9
                let $block := 4
                for {} true {} {
                    switch $block
                    case 2 {
                        // label L0
                        // $t7 := >=($t4, $t2)
                        /// @src 1:6163:6197
                        $t7 := $GtEq($t4, amount)
                        // $t8 := [69, 82, 67, 50, 48, 58, 32, 105, 110, 115, 117, 102, 102, 105, 99, 105, 101, 110, 116, 32, 97, 108, 108, 111, 119, 97, 110, 99, 101]
                        /// @src 1:6199:6231
                        $t8 := $Malloc(61)
                        $MemoryStoreU64($t8, 29)
                        $MemoryStoreU64(add($t8, 8), $ClosestGreaterPowerOfTwo(61))
                        let $offs_3758581307 := add($t8, 32)
                        $MemoryStoreU8($offs_3758581307, 69)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        $MemoryStoreU8($offs_3758581307, 82)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        $MemoryStoreU8($offs_3758581307, 67)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        $MemoryStoreU8($offs_3758581307, 50)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        $MemoryStoreU8($offs_3758581307, 48)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        $MemoryStoreU8($offs_3758581307, 58)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        $MemoryStoreU8($offs_3758581307, 32)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        $MemoryStoreU8($offs_3758581307, 105)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        $MemoryStoreU8($offs_3758581307, 110)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        $MemoryStoreU8($offs_3758581307, 115)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        $MemoryStoreU8($offs_3758581307, 117)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        $MemoryStoreU8($offs_3758581307, 102)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        $MemoryStoreU8($offs_3758581307, 102)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        $MemoryStoreU8($offs_3758581307, 105)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        $MemoryStoreU8($offs_3758581307, 99)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        $MemoryStoreU8($offs_3758581307, 105)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        $MemoryStoreU8($offs_3758581307, 101)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        $MemoryStoreU8($offs_3758581307, 110)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        $MemoryStoreU8($offs_3758581307, 116)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        $MemoryStoreU8($offs_3758581307, 32)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        $MemoryStoreU8($offs_3758581307, 97)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        $MemoryStoreU8($offs_3758581307, 108)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        $MemoryStoreU8($offs_3758581307, 108)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        $MemoryStoreU8($offs_3758581307, 111)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        $MemoryStoreU8($offs_3758581307, 119)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        $MemoryStoreU8($offs_3758581307, 97)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        $MemoryStoreU8($offs_3758581307, 110)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        $MemoryStoreU8($offs_3758581307, 99)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        $MemoryStoreU8($offs_3758581307, 101)
                        $offs_3758581307 := add($offs_3758581307, 1)
                        // Evm::require($t7, $t8)
                        /// @src 1:6155:6232
                        A2_Evm_require($t7, $t8)
                        // $t9 := -($t4, $t2)
                        /// @src 1:6271:6306
                        $t9 := $Sub($t4, amount)
                        // ERC20Mock::approve_($t0, $t1, $t9)
                        /// @src 1:6246:6307
                        A2_ERC20Mock_approve_(owner, spender, $t9)
                        // goto L2
                        /// @src 1:6104:6318
                        $block := 3
                    }
                    case 3 {
                        // label L2
                        // return ()
                        /// @src 1:6104:6318
                        leave
                    }
                    case 4 {
                        // $t4 := ERC20Mock::allowance($t0, $t1)
                        /// @src 1:6069:6094
                        $t4 := A2_ERC20Mock_allowance(owner, spender)
                        // $t5 := U256::max()
                        /// @src 1:6128:6139
                        $t5 := A2_U256_max()
                        // $t6 := !=($t4, $t5)
                        /// @src 1:6125:6127
                        $t6 := $Neq($t4, $t5)
                        // if ($t6) goto L0 else goto L2
                        /// @src 1:6104:6318
                        switch $t6
                        case 0  { $block := 3 }
                        default { $block := 2 }
                    }
                }
            }

            function A2_U256_max() -> $result {
                let $t0
                // $t0 := 115792089237316195423570985008687907853269984665640564039457584007913129639935
                /// @src 2:1123:1158
                $t0 := 115792089237316195423570985008687907853269984665640564039457584007913129639935
                // return $t0
                /// @src 2:1123:1158
                $result := $t0
            }

            function A2_ERC20Mock_approve_(owner, spender, amount) {
                let tmp_$3, tmp_$4, a, s, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23, $t24, $t25, $t26, $t27, $t28, $t29, $t30, $t31, $t32, $t33, $t34, $t35, $t36
                let $locals := $Malloc(64)
                mstore($locals, owner)
                mstore(add($locals, 32), spender)
                let $block := 4
                for {} true {} {
                    switch $block
                    case 2 {
                        // label L0
                        // $t21 := borrow_field<ERC20Mock::State>.allowances($t16)
                        /// @src 1:6731:6748
                        $t21 := $IndexPtr($t16, 96)
                        // $t22 := borrow_local($t0)
                        /// @src 1:6750:6756
                        $t22 := $MakePtr(false, $locals)
                        // $t23 := Table::empty<address, U256::U256>()
                        /// @src 1:6758:6787
                        $t23 := A2_Table_empty$address_A2_U256_U256$()
                        // Table::insert<address, Table::Table<address, U256::U256>>($t21, $t22, $t23)
                        /// @src 1:6717:6788
                        A2_Table_insert$address_A2_Table_Table$address_A2_U256_U256$$($t21, $t22, $t23)
                        // goto L2
                        /// @src 1:6839:6840
                        $block := 3
                    }
                    case 3 {
                        // label L2
                        // $t24 := borrow_field<ERC20Mock::State>.allowances($t16)
                        /// @src 1:6834:6851
                        $t24 := $IndexPtr($t16, 96)
                        // $t25 := borrow_local($t0)
                        /// @src 1:6853:6859
                        $t25 := $MakePtr(false, $locals)
                        // $t26 := Table::borrow_mut<address, Table::Table<address, U256::U256>>($t24, $t25)
                        /// @src 1:6816:6860
                        $t26 := A2_Table_borrow_mut$address_A2_Table_Table$address_A2_U256_U256$$($t24, $t25)
                        // $t27 := borrow_local($t1)
                        /// @src 1:6893:6901
                        $t27 := $MakePtr(false, add($locals, 32))
                        // $t28 := freeze_ref($t26)
                        /// @src 1:6889:6902
                        $t28 := $t26
                        // $t29 := Table::contains<address, U256::U256>($t28, $t27)
                        /// @src 1:6874:6902
                        $t29 := A2_Table_contains$address_A2_U256_U256$($t28, $t27)
                        // $t30 := !($t29)
                        /// @src 1:6873:6874
                        $t30 := $LogicalNot($t29)
                        // if ($t30) goto L3 else goto L5
                        /// @src 1:6870:7042
                        switch $t30
                        case 0  { $block := 6 }
                        default { $block := 5 }
                    }
                    case 4 {
                        // $t7 := copy($t0)
                        /// @src 1:6471:6476
                        $t7 := mload($locals)
                        // $t8 := 0x0
                        /// @src 1:6480:6484
                        $t8 := 0x0
                        // $t9 := !=($t7, $t8)
                        /// @src 1:6477:6479
                        $t9 := $Neq($t7, $t8)
                        // $t10 := [69, 82, 67, 50, 48, 58, 32, 97, 112, 112, 114, 111, 118, 101, 32, 102, 114, 111, 109, 32, 116, 104, 101, 32, 122, 101, 114, 111, 32, 97, 100, 100, 114, 101, 115, 115]
                        /// @src 1:6486:6525
                        $t10 := $Malloc(68)
                        $MemoryStoreU64($t10, 36)
                        $MemoryStoreU64(add($t10, 8), $ClosestGreaterPowerOfTwo(68))
                        let $offs_2280936393 := add($t10, 32)
                        $MemoryStoreU8($offs_2280936393, 69)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 82)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 67)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 50)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 48)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 58)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 32)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 97)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 112)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 112)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 114)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 111)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 118)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 101)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 32)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 102)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 114)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 111)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 109)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 32)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 116)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 104)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 101)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 32)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 122)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 101)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 114)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 111)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 32)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 97)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 100)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 100)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 114)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 101)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 115)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        $MemoryStoreU8($offs_2280936393, 115)
                        $offs_2280936393 := add($offs_2280936393, 1)
                        // Evm::require($t9, $t10)
                        /// @src 1:6463:6526
                        A2_Evm_require($t9, $t10)
                        // $t11 := copy($t1)
                        /// @src 1:6544:6551
                        $t11 := mload(add($locals, 32))
                        // $t12 := 0x0
                        /// @src 1:6555:6559
                        $t12 := 0x0
                        // $t13 := !=($t11, $t12)
                        /// @src 1:6552:6554
                        $t13 := $Neq($t11, $t12)
                        // $t14 := [69, 82, 67, 50, 48, 58, 32, 97, 112, 112, 114, 111, 118, 101, 32, 116, 111, 32, 116, 104, 101, 32, 122, 101, 114, 111, 32, 97, 100, 100, 114, 101, 115, 115]
                        /// @src 1:6561:6598
                        $t14 := $Malloc(66)
                        $MemoryStoreU64($t14, 34)
                        $MemoryStoreU64(add($t14, 8), $ClosestGreaterPowerOfTwo(66))
                        let $offs_3309078564 := add($t14, 32)
                        $MemoryStoreU8($offs_3309078564, 69)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 82)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 67)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 50)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 48)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 58)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 32)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 97)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 112)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 112)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 114)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 111)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 118)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 101)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 32)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 116)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 111)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 32)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 116)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 104)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 101)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 32)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 122)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 101)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 114)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 111)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 32)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 97)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 100)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 100)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 114)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 101)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 115)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        $MemoryStoreU8($offs_3309078564, 115)
                        $offs_3309078564 := add($offs_3309078564, 1)
                        // Evm::require($t13, $t14)
                        /// @src 1:6536:6599
                        A2_Evm_require($t13, $t14)
                        // $t15 := Evm::self()
                        /// @src 1:6642:6648
                        $t15 := A2_Evm_self()
                        // $t16 := borrow_global<ERC20Mock::State>($t15)
                        /// @src 1:6617:6634
                        {
                            let $base_offset := $MakeTypeStorageBase(0, 0xa937cc63, $t15)
                            if iszero($AlignedStorageLoad($base_offset)) {
                              $AbortBuiltin()
                            }
                            $t16 := $MakePtr(true, add($base_offset, 32))
                        }
                        // $t17 := borrow_field<ERC20Mock::State>.allowances($t16)
                        /// @src 1:6679:6692
                        $t17 := $IndexPtr($t16, 96)
                        // $t18 := borrow_local($t0)
                        /// @src 1:6694:6700
                        $t18 := $MakePtr(false, $locals)
                        // $t19 := Table::contains<address, Table::Table<address, U256::U256>>($t17, $t18)
                        /// @src 1:6663:6701
                        $t19 := A2_Table_contains$address_A2_Table_Table$address_A2_U256_U256$$($t17, $t18)
                        // $t20 := !($t19)
                        /// @src 1:6662:6663
                        $t20 := $LogicalNot($t19)
                        // if ($t20) goto L0 else goto L2
                        /// @src 1:6659:6798
                        switch $t20
                        case 0  { $block := 3 }
                        default { $block := 2 }
                    }
                    case 5 {
                        // label L3
                        // $t31 := borrow_local($t1)
                        /// @src 1:6935:6943
                        $t31 := $MakePtr(false, add($locals, 32))
                        // Table::insert<address, U256::U256>($t26, $t31, $t2)
                        /// @src 1:6918:6952
                        A2_Table_insert$address_A2_U256_U256$($t26, $t31, amount)
                        // goto L6
                        /// @src 1:6952:6953
                        $block := 7
                    }
                    case 6 {
                        // label L5
                        // $t32 := borrow_local($t1)
                        /// @src 1:7013:7021
                        $t32 := $MakePtr(false, add($locals, 32))
                        // $t33 := Table::borrow_mut<address, U256::U256>($t26, $t32)
                        /// @src 1:6992:7022
                        $t33 := A2_Table_borrow_mut$address_A2_U256_U256$($t26, $t32)
                        // write_ref($t33, $t2)
                        /// @src 1:6991:7031
                        $StoreU256($t33, amount)
                        // goto L6
                        /// @src 1:7066:7071
                        $block := 7
                    }
                    case 7 {
                        // label L6
                        // $t34 := move($t0)
                        /// @src 1:7066:7071
                        $t34 := mload($locals)
                        // $t35 := move($t1)
                        /// @src 1:7073:7080
                        $t35 := mload(add($locals, 32))
                        // $t36 := pack ERC20Mock::Approval($t34, $t35, $t2)
                        /// @src 1:7057:7096
                        {
                            let $mem := $Malloc(96)
                            $MemoryStoreU256(add($mem, 0), $t34)
                            $MemoryStoreU256(add($mem, 32), $t35)
                            $MemoryStoreU256(add($mem, 64), amount)
                            $t36 := $mem
                        }
                        // Evm::emit<ERC20Mock::Approval>($t36)
                        /// @src 1:7052:7097
                        A2_Evm_emit$A2_ERC20Mock_Approval$($t36)
                        // return ()
                        /// @src 1:7097:7098
                        $Free($locals, 64)
                        leave
                    }
                }
            }

            function A2_Evm_emit$A2_ERC20Mock_Approval$(e) {
                let $t1 := 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925
                let $t2 := $MemoryLoadU256(add(e, 0))
                let $t3 := $MemoryLoadU256(add(e, 32))
                let $t4 := $MemoryLoadU256(add(e, 64))
                {
                    let $t5 := mload(0)
                    let $t6 := abi_encode_tuple_$uint256$_$A2_U256_U256$($t5, $t4)
                    log3($t5, sub($t6, $t5), $t1,$t2,$t3)
                }
            }
            function A2_Table_contains$address_A2_Table_Table$address_A2_U256_U256$$(table_ref, key_ref) -> res {
                let key := $LoadU256(key_ref)
                let table_handle := $LoadU256(table_ref)
                let storage_key := $StorageKey(table_handle, key)
                let word := sload(storage_key)
                res := $LogicalNot(iszero(word))
            }
            function A2_Table_borrow_mut$address_A2_Table_Table$address_A2_U256_U256$$(table_ref, key_ref) -> value_ref {
                let key := $LoadU256(key_ref)
                let table_handle := $LoadU256(table_ref)
                let storage_key := $StorageKey(table_handle, key)
                let value_offs := sload(storage_key)
                if iszero(value_offs) {
                  $AbortBuiltin()
                }
                value_ref := $MakePtr(true, value_offs)
            }
            function A2_Table_insert$address_A2_Table_Table$address_A2_U256_U256$$(table_ref, key_ref, value) {
                let key := $LoadU256(key_ref)
                let table_handle := $LoadU256(table_ref)
                let storage_key := $StorageKey(table_handle, key)
                let word := sload(storage_key)
                if $LogicalNot(iszero(word)) {
                  $AbortBuiltin()
                }
                let $linked_dst_3228464714 := $NewLinkedStorageBase(0xc06e764a)
                $StorageStoreU256($linked_dst_3228464714, value)
                sstore(storage_key, $linked_dst_3228464714)
            }
            function A2_Table_empty$address_A2_U256_U256$() -> table {
                table := $NewTableHandle()
            }
            function A2_Evm_sender() -> $result {
                let $t0
                // $t0 := Evm::msg_sender()
                /// @src 4:487:499
                $t0 := A2_Evm_msg_sender()
                // return $t0
                /// @src 4:487:499
                $result := $t0
            }

            function A2_Evm_msg_sender() -> result {
              result := caller()
            }
            function A2_ERC20Mock_mint_(account, amount) {
                let mut_bal_account, s, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17
                // $t4 := 0x0
                /// @src 1:8739:8743
                $t4 := 0x0
                // $t5 := !=($t0, $t4)
                /// @src 1:8736:8738
                $t5 := $Neq(account, $t4)
                // $t6 := [69, 82, 67, 50, 48, 58, 32, 109, 105, 110, 116, 32, 116, 111, 32, 116, 104, 101, 32, 122, 101, 114, 111, 32, 97, 100, 100, 114, 101, 115, 115]
                /// @src 1:8745:8779
                $t6 := $Malloc(63)
                $MemoryStoreU64($t6, 31)
                $MemoryStoreU64(add($t6, 8), $ClosestGreaterPowerOfTwo(63))
                let $offs_473435132 := add($t6, 32)
                $MemoryStoreU8($offs_473435132, 69)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 82)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 67)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 50)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 48)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 58)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 32)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 109)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 105)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 110)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 116)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 32)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 116)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 111)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 32)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 116)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 104)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 101)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 32)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 122)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 101)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 114)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 111)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 32)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 97)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 100)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 100)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 114)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 101)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 115)
                $offs_473435132 := add($offs_473435132, 1)
                $MemoryStoreU8($offs_473435132, 115)
                $offs_473435132 := add($offs_473435132, 1)
                // Evm::require($t5, $t6)
                /// @src 1:8720:8780
                A2_Evm_require($t5, $t6)
                // $t7 := Evm::self()
                /// @src 1:8823:8829
                $t7 := A2_Evm_self()
                // $t8 := borrow_global<ERC20Mock::State>($t7)
                /// @src 1:8798:8815
                {
                    let $base_offset := $MakeTypeStorageBase(0, 0xa937cc63, $t7)
                    if iszero($AlignedStorageLoad($base_offset)) {
                      $AbortBuiltin()
                    }
                    $t8 := $MakePtr(true, add($base_offset, 32))
                }
                // $t9 := borrow_field<ERC20Mock::State>.total_supply($t8)
                /// @src 1:8867:8881
                $t9 := $IndexPtr($t8, 128)
                // $t10 := read_ref($t9)
                /// @src 1:8867:8881
                $t10 := $LoadU256($t9)
                // $t11 := +($t10, $t1)
                /// @src 1:8857:8890
                $t11 := $AddU256($t10, amount)
                // $t12 := borrow_field<ERC20Mock::State>.total_supply($t8)
                /// @src 1:8840:8854
                $t12 := $IndexPtr($t8, 128)
                // write_ref($t12, $t11)
                /// @src 1:8840:8890
                $StoreU256($t12, $t11)
                // $t13 := ERC20Mock::mut_balanceOf($t8, $t0)
                /// @src 1:8922:8947
                $t13 := A2_ERC20Mock_mut_balanceOf($t8, account)
                // $t14 := read_ref($t13)
                /// @src 1:8986:9002
                $t14 := $LoadU256($t13)
                // $t15 := +($t14, $t1)
                /// @src 1:8976:9011
                $t15 := $AddU256($t14, amount)
                // write_ref($t13, $t15)
                /// @src 1:8957:9011
                $StoreU256($t13, $t15)
                // $t16 := 0x0
                /// @src 1:9041:9045
                $t16 := 0x0
                // $t17 := pack ERC20Mock::Transfer($t16, $t0, $t1)
                /// @src 1:9026:9074
                {
                    let $mem := $Malloc(96)
                    $MemoryStoreU256(add($mem, 0), $t16)
                    $MemoryStoreU256(add($mem, 32), account)
                    $MemoryStoreU256(add($mem, 64), amount)
                    $t17 := $mem
                }
                // Evm::emit<ERC20Mock::Transfer>($t17)
                /// @src 1:9021:9075
                A2_Evm_emit$A2_ERC20Mock_Transfer$($t17)
                // return ()
                /// @src 1:9075:9076
            }

            function A2_ERC20Mock_burn_(account, amount) {
                let mut_bal_account, s, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20
                // $t4 := 0x0
                /// @src 1:9250:9254
                $t4 := 0x0
                // $t5 := !=($t0, $t4)
                /// @src 1:9247:9249
                $t5 := $Neq(account, $t4)
                // $t6 := [69, 82, 67, 50, 48, 58, 32, 98, 117, 114, 110, 32, 102, 114, 111, 109, 32, 116, 104, 101, 32, 122, 101, 114, 111, 32, 97, 100, 100, 114, 101, 115, 115]
                /// @src 1:9256:9292
                $t6 := $Malloc(65)
                $MemoryStoreU64($t6, 33)
                $MemoryStoreU64(add($t6, 8), $ClosestGreaterPowerOfTwo(65))
                let $offs_1233676209 := add($t6, 32)
                $MemoryStoreU8($offs_1233676209, 69)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 82)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 67)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 50)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 48)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 58)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 32)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 98)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 117)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 114)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 110)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 32)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 102)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 114)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 111)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 109)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 32)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 116)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 104)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 101)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 32)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 122)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 101)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 114)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 111)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 32)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 97)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 100)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 100)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 114)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 101)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 115)
                $offs_1233676209 := add($offs_1233676209, 1)
                $MemoryStoreU8($offs_1233676209, 115)
                $offs_1233676209 := add($offs_1233676209, 1)
                // Evm::require($t5, $t6)
                /// @src 1:9231:9293
                A2_Evm_require($t5, $t6)
                // $t7 := Evm::self()
                /// @src 1:9336:9342
                $t7 := A2_Evm_self()
                // $t8 := borrow_global<ERC20Mock::State>($t7)
                /// @src 1:9311:9328
                {
                    let $base_offset := $MakeTypeStorageBase(0, 0xa937cc63, $t7)
                    if iszero($AlignedStorageLoad($base_offset)) {
                      $AbortBuiltin()
                    }
                    $t8 := $MakePtr(true, add($base_offset, 32))
                }
                // $t9 := ERC20Mock::mut_balanceOf($t8, $t0)
                /// @src 1:9375:9400
                $t9 := A2_ERC20Mock_mut_balanceOf($t8, account)
                // $t10 := read_ref($t9)
                /// @src 1:9427:9443
                $t10 := $LoadU256($t9)
                // $t11 := >=($t10, $t1)
                /// @src 1:9418:9452
                $t11 := $GtEq($t10, amount)
                // $t12 := [69, 82, 67, 50, 48, 58, 32, 98, 117, 114, 110, 32, 97, 109, 111, 117, 110, 116, 32, 101, 120, 99, 101, 101, 100, 115, 32, 98, 97, 108, 97, 110, 99, 101]
                /// @src 1:9454:9491
                $t12 := $Malloc(66)
                $MemoryStoreU64($t12, 34)
                $MemoryStoreU64(add($t12, 8), $ClosestGreaterPowerOfTwo(66))
                let $offs_1846713108 := add($t12, 32)
                $MemoryStoreU8($offs_1846713108, 69)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 82)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 67)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 50)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 48)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 58)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 32)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 98)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 117)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 114)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 110)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 32)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 97)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 109)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 111)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 117)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 110)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 116)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 32)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 101)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 120)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 99)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 101)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 101)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 100)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 115)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 32)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 98)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 97)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 108)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 97)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 110)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 99)
                $offs_1846713108 := add($offs_1846713108, 1)
                $MemoryStoreU8($offs_1846713108, 101)
                $offs_1846713108 := add($offs_1846713108, 1)
                // Evm::require($t11, $t12)
                /// @src 1:9410:9492
                A2_Evm_require($t11, $t12)
                // $t13 := read_ref($t9)
                /// @src 1:9531:9547
                $t13 := $LoadU256($t9)
                // $t14 := -($t13, $t1)
                /// @src 1:9521:9556
                $t14 := $Sub($t13, amount)
                // write_ref($t9, $t14)
                /// @src 1:9502:9556
                $StoreU256($t9, $t14)
                // $t15 := borrow_field<ERC20Mock::State>.total_supply($t8)
                /// @src 1:9593:9607
                $t15 := $IndexPtr($t8, 128)
                // $t16 := read_ref($t15)
                /// @src 1:9593:9607
                $t16 := $LoadU256($t15)
                // $t17 := -($t16, $t1)
                /// @src 1:9583:9616
                $t17 := $Sub($t16, amount)
                // $t18 := borrow_field<ERC20Mock::State>.total_supply($t8)
                /// @src 1:9566:9580
                $t18 := $IndexPtr($t8, 128)
                // write_ref($t18, $t17)
                /// @src 1:9566:9616
                $StoreU256($t18, $t17)
                // $t19 := 0x0
                /// @src 1:9659:9663
                $t19 := 0x0
                // $t20 := pack ERC20Mock::Transfer($t0, $t19, $t1)
                /// @src 1:9631:9679
                {
                    let $mem := $Malloc(96)
                    $MemoryStoreU256(add($mem, 0), account)
                    $MemoryStoreU256(add($mem, 32), $t19)
                    $MemoryStoreU256(add($mem, 64), amount)
                    $t20 := $mem
                }
                // Evm::emit<ERC20Mock::Transfer>($t20)
                /// @src 1:9626:9680
                A2_Evm_emit$A2_ERC20Mock_Transfer$($t20)
                // return ()
                /// @src 1:9680:9681
            }

            function A2_ERC20Mock_mut_allowance(s, owner, spender) -> $result {
                let allowance_owner, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16
                let $locals := $Malloc(64)
                mstore($locals, owner)
                mstore(add($locals, 32), spender)
                let $block := 4
                for {} true {} {
                    switch $block
                    case 2 {
                        // label L0
                        // $t8 := borrow_field<ERC20Mock::State>.allowances($t0)
                        /// @src 1:8096:8113
                        $t8 := $IndexPtr(s, 96)
                        // $t9 := borrow_local($t1)
                        /// @src 1:8115:8121
                        $t9 := $MakePtr(false, $locals)
                        // $t10 := Table::empty<address, U256::U256>()
                        /// @src 1:8123:8152
                        $t10 := A2_Table_empty$address_A2_U256_U256$()
                        // Table::insert<address, Table::Table<address, U256::U256>>($t8, $t9, $t10)
                        /// @src 1:8082:8153
                        A2_Table_insert$address_A2_Table_Table$address_A2_U256_U256$$($t8, $t9, $t10)
                        // goto L2
                        /// @src 1:8218:8219
                        $block := 3
                    }
                    case 3 {
                        // label L2
                        // $t11 := borrow_field<ERC20Mock::State>.allowances($t0)
                        /// @src 1:8213:8230
                        $t11 := $IndexPtr(s, 96)
                        // $t12 := borrow_local($t1)
                        /// @src 1:8232:8238
                        $t12 := $MakePtr(false, $locals)
                        // $t13 := Table::borrow_mut<address, Table::Table<address, U256::U256>>($t11, $t12)
                        /// @src 1:8195:8239
                        $t13 := A2_Table_borrow_mut$address_A2_Table_Table$address_A2_U256_U256$$($t11, $t12)
                        // $t14 := borrow_local($t2)
                        /// @src 1:8297:8305
                        $t14 := $MakePtr(false, add($locals, 32))
                        // $t15 := U256::zero()
                        /// @src 1:8307:8319
                        $t15 := A2_U256_zero()
                        // $t16 := Table::borrow_mut_with_default<address, U256::U256>($t13, $t14, $t15)
                        /// @src 1:8249:8320
                        $t16 := A2_Table_borrow_mut_with_default$address_A2_U256_U256$($t13, $t14, $t15)
                        // return $t16
                        /// @src 1:8249:8320
                        $result := $t16
                        $Free($locals, 64)
                        leave
                    }
                    case 4 {
                        // $t4 := borrow_field<ERC20Mock::State>.allowances($t0)
                        /// @src 1:8044:8057
                        $t4 := $IndexPtr(s, 96)
                        // $t5 := borrow_local($t1)
                        /// @src 1:8059:8065
                        $t5 := $MakePtr(false, $locals)
                        // $t6 := Table::contains<address, Table::Table<address, U256::U256>>($t4, $t5)
                        /// @src 1:8028:8066
                        $t6 := A2_Table_contains$address_A2_Table_Table$address_A2_U256_U256$$($t4, $t5)
                        // $t7 := !($t6)
                        /// @src 1:8027:8028
                        $t7 := $LogicalNot($t6)
                        // if ($t7) goto L0 else goto L2
                        /// @src 1:8024:8163
                        switch $t7
                        case 0  { $block := 3 }
                        default { $block := 2 }
                    }
                }
            }

            function abi_encode_tuple_$uint256$_$A2_U256_U256$(headStart ,value_0) -> tail {
                tail := add(headStart, 32)
                abi_encode_uint256(value_0, add(headStart, 0))
            }
            function abi_encode_uint256(value, pos) {
                mstore(pos, cleanup_uint256(value))
            }
            function cleanup_uint256(value) -> cleaned {
                cleaned := and(value, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)
            }
            function abi_encode_tuple__(headStart ) -> tail {
                tail := add(headStart, 0)
            }
            function abi_decode_tuple_$address_address_uint256$_$address_address_A2_U256_U256$(headStart, dataEnd) -> value_0, value_1, value_2 {
                if slt(sub(dataEnd, headStart), 96) { $Abort(96) }
                {
                    let offset := 0
                    value_0 := abi_decode_address(add(headStart, offset), dataEnd)
                }
                {
                    let offset := 32
                    value_1 := abi_decode_address(add(headStart, offset), dataEnd)
                }
                {
                    let offset := 64
                    value_2 := abi_decode_uint256(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_uint256(offset, end) -> value {
                value := calldataload(offset)
                validator_uint256(value)
            }
            function validator_uint256(value) {
                if iszero(eq(value, cleanup_uint256(value))) { $Abort(95) }
            }
            function abi_decode_address(offset, end) -> value {
                value := calldataload(offset)
                validator_address(value)
            }
            function validator_address(value) {
                if iszero(eq(value, cleanup_address(value))) { $Abort(95) }
            }
            function cleanup_address(value) -> cleaned {
                cleaned := and(value, 0xffffffffffffffffffffffffffffffffffffffff)
            }
            function abi_encode_tuple_$bool$_$bool$(headStart ,value_0) -> tail {
                tail := add(headStart, 32)
                abi_encode_bool(value_0, add(headStart, 0))
            }
            function abi_encode_bool(value, pos) {
                mstore(pos, cleanup_bool(value))
            }
            function cleanup_bool(value) -> cleaned {
                cleaned := and(value, 0xff)
            }
            function abi_decode_tuple_$address_uint256$_$address_A2_U256_U256$(headStart, dataEnd) -> value_0, value_1 {
                if slt(sub(dataEnd, headStart), 64) { $Abort(96) }
                {
                    let offset := 0
                    value_0 := abi_decode_address(add(headStart, offset), dataEnd)
                }
                {
                    let offset := 32
                    value_1 := abi_decode_uint256(add(headStart, offset), dataEnd)
                }
            }
            function abi_encode_tuple_$uint8$_$u8$(headStart ,value_0) -> tail {
                tail := add(headStart, 32)
                abi_encode_uint8(value_0, add(headStart, 0))
            }
            function abi_encode_uint8(value, pos) {
                mstore(pos, cleanup_uint8(value))
            }
            function cleanup_uint8(value) -> cleaned {
                cleaned := and(value, 0xff)
            }
            function abi_encode_tuple_$string$_$vec$u8$$(headStart ,value_0) -> tail {
                tail := add(headStart, 32)
                mstore(add(headStart, 0), sub(tail, headStart))
                tail := abi_encode_string(value_0,  tail)
            }
            function abi_encode_string(value, pos) -> end{
                let size := $MemoryLoadU64(value)
                mstore(pos, size)
                pos := add(pos, 0x20)
                $CopyMemoryU8(add(value, 0x20), pos, size)
                size := $RoundUp(size)
                end := add(pos, size)
            }
            function abi_decode_tuple_$address$_$address$(headStart, dataEnd) -> value_0 {
                if slt(sub(dataEnd, headStart), 32) { $Abort(96) }
                {
                    let offset := 0
                    value_0 := abi_decode_address(add(headStart, offset), dataEnd)
                }
            }
            function abi_decode_tuple_$address_address$_$address_address$(headStart, dataEnd) -> value_0, value_1 {
                if slt(sub(dataEnd, headStart), 64) { $Abort(96) }
                {
                    let offset := 0
                    value_0 := abi_decode_address(add(headStart, offset), dataEnd)
                }
                {
                    let offset := 32
                    value_1 := abi_decode_address(add(headStart, offset), dataEnd)
                }
            }
            function $Abort(code) {
                mstore(0, code)
                revert(24, 8) // TODO: store code as a string?
            }
            function $AbortBuiltin() {
                $Abort(sub(0, 1))
            }
            function $Malloc(size) -> offs {
                offs := mload(0)
                // pad to word size
                mstore(0, add(offs, shl(5, shr(5, add(size, 31)))))
            }
            function $Free(offs, size) {
            }
            function $MakePtr(is_storage, offs) -> ptr {
              ptr := or(is_storage, shl(1, offs))
            }
            function $IsStoragePtr(ptr) -> b {
              b := and(ptr, 0x1)
            }
            function $OffsetPtr(ptr) -> offs {
              offs := shr(1, ptr)
            }
            function $MaskForSize(size) -> mask {
              mask := sub(shl(shl(3, size), 1), 1)
            }
            function $ExtractBytes(word, start, size) -> bytes {
               switch size
               case 1 {
                  // use the faster byte primitive
                  bytes := byte(start, word)
               }
               default {
                  // As we have big endian, we need to right shift the value from
                  // where the highest byte starts in the word (32 - start), minus
                  // the size.
                  let shift_bits := shl(3, sub(sub(32, start), size))
                  bytes := and(shr(shift_bits, word), $MaskForSize(size))
               }
            }
            function $InjectBytes(word, start, size, bytes) -> new_word {
               let shift_bits := shl(3, sub(sub(32, start), size))
               // Blend out the bits which we inject
               let neg_mask := not(shl(shift_bits, $MaskForSize(size)))
               word := and(word, neg_mask)
               // Overlay the bits we inject
               new_word := or(word, shl(shift_bits, bytes))
            }
            function $ToWordOffs(offs) -> word_offs, byte_offset {
              word_offs := shr(5, offs)
              byte_offset := and(offs, 0x1F)
            }
            function $OverflowBytes(byte_offset, size) -> overflow_bytes {
              let available_bytes := sub(32, byte_offset)
              switch gt(size, available_bytes)
              case 0 {
                overflow_bytes := 0
              }
              default {
                overflow_bytes := sub(size, available_bytes)
              }
            }
            function $MemoryLoadBytes(offs, size) -> val {
              // Lower bit where the value in the higher bytes ends
              let bit_end := shl(3, sub(32, size))
              val := shr(bit_end, mload(offs))
            }
            function $MemoryStoreBytes(offs, size, val) {
              let bit_end := shl(3, sub(32, size))
              let mask := shl(bit_end, $MaskForSize(size))
              mstore(offs, or(and(mload(offs), not(mask)), shl(bit_end, val)))
            }
            function $StorageLoadBytes(offs, size) -> val {
              let word_offs, byte_offs := $ToWordOffs(offs)
              let key := $StorageKey(0, word_offs)
              val := $ExtractBytes(sload(key), byte_offs, size)
              let overflow_bytes := $OverflowBytes(byte_offs, size)
              if $LogicalNot(iszero(overflow_bytes)) {
                key := $StorageKey(0, add(word_offs, 1))
                let extra_bytes := $ExtractBytes(sload(key), 0, overflow_bytes)
                val := or(shl(shl(3, overflow_bytes), val), extra_bytes)
              }
            }
            function $StorageStoreBytes(offs, size, bytes) {
              let word_offs, byte_offs := $ToWordOffs(offs)
              let key := $StorageKey(0, word_offs)
              let overflow_bytes := $OverflowBytes(byte_offs, size)
              switch overflow_bytes
              case 0 {
                sstore(key, $InjectBytes(sload(key), byte_offs, size, bytes))
              }
              default {
                // Shift the higher bytes to the right
                let used_bytes := sub(size, overflow_bytes)
                let higher_bytes := shr(used_bytes, bytes)
                let lower_bytes := and(bytes, $MaskForSize(overflow_bytes))
                sstore(key, $InjectBytes(sload(key), byte_offs, used_bytes, higher_bytes))
                key := $StorageKey(0, add(word_offs, 1))
                sstore(key, $InjectBytes(sload(key), 0, overflow_bytes, lower_bytes))
              }
            }
            function $StorageKey(group, word) -> key {
              mstore(32, word)
              mstore(64, shl(224, group))
              key := keccak256(32, 36)
              //let mask := sub(shl(shl(3, 28), 1), 1)
              //let masked_word := and(word, mask)
              //key := or(shl(224, group), masked_word)
            }
            function $MakeTypeStorageBase(category, type_hash, id) -> offs {
              offs := or(shl(252, category), or(shl(220, type_hash), shl(60, id)))
            }
            function $NewLinkedStorageBase(type_hash) -> offs {
              let key := $StorageKey(1, 1)
              let handle := sload(key)
              sstore(key, add(handle, 1))
              offs := $MakeTypeStorageBase(1, type_hash, handle)
            }
            function $IndexPtr(ptr, offs) -> new_ptr {
              new_ptr := $MakePtr($IsStoragePtr(ptr), add($OffsetPtr(ptr), offs))
            }
            function $NewTableHandle() -> handle {
              let key := $StorageKey(1, 0)
              handle := sload(key)
              if iszero(handle) {
                 // no tables have been allocated in this contract, need to initialize the counter
                 // to the number of storage groups already statically allocated
                 handle := 2
              }
              sstore(key, add(handle, 1))
            }

            function $MemoryStoreU8(offs, val) {
              // Shortcut via special instruction
              mstore8(offs, val)
            }
            function $MemoryLoadU64(offs) -> val {
              val := $MemoryLoadBytes(offs, 8)
            }
            function $StorageLoadU64(offs) -> val {
              val := $StorageLoadBytes(offs, 8)
            }
            function $MemoryStoreU64(offs, val) {
              $MemoryStoreBytes(offs, 8, val)
            }
            function $LoadU256(ptr) -> val {
              let offs := $OffsetPtr(ptr)
              switch $IsStoragePtr(ptr)
              case 0 {
                val := $MemoryLoadU256(offs)
              }
              default {
                val := $StorageLoadU256(offs)
              }
            }
            function $MemoryLoadU256(offs) -> val {
              val := $MemoryLoadBytes(offs, 32)
            }
            function $StorageLoadU256(offs) -> val {
              val := $StorageLoadBytes(offs, 32)
            }
            function $StoreU256(ptr, val) {
              let offs := $OffsetPtr(ptr)
              switch $IsStoragePtr(ptr)
              case 0 {
                $MemoryStoreU256(offs, val)
              }
              default {
                $StorageStoreU256(offs, val)
              }
            }
            function $MemoryStoreU256(offs, val) {
              $MemoryStoreBytes(offs, 32, val)
            }
            function $StorageStoreU256(offs, val) {
              $StorageStoreBytes(offs, 32, val)
            }
            function $AlignedStorageLoad(offs) -> val {
              let word_offs := shr(5, offs)
              val := sload($StorageKey(0, word_offs))
            }
            function $CopyMemoryU8(src, dst, size) {
              let i := 0
              for { } lt(i, size) { i := add(i, 32) } {
                mstore(add(dst, i), mload(add(src, i)))
              }
              if gt(i, size)
              {
                  for {let j := i} lt(j, size) {j := add(j, 1)} {
                    mstore8(add(dst, j), 0)
                  }
              }
            }
            function $AddU256(x, y) -> r {
                if lt(sub(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, x), y) { $AbortBuiltin() }
                r := add(x, y)
            }
            function $Sub(x, y) -> r {
                if lt(x, y) { $AbortBuiltin() }
                r := sub(x, y)
            }
            function $Shr(x, y) -> r {
                r := shr(y, x)
            }
            function $GtEq(x, y) -> r {
                r := or(gt(x, y), eq(x, y))
            }
            function $LtEq(x, y) -> r {
                r := or(lt(x, y), eq(x, y))
            }
            function $Neq(x, y) -> r {
                r := $LogicalNot(eq(x, y))
            }
            function $LogicalNot(x) -> r {
                r := iszero(x)
            }
            function $ClosestGreaterPowerOfTwo(x) -> r {
                r := or(r, shr(1, x))
                r := or(r, shr(2, r))
                r := or(r, shr(4, r))
                r := or(r, shr(8, r))
                r := or(r, shr(16, r))
                r := or(r, shr(32, r))
                r := add(x, 1)
            }
            function $RoundUp(value) -> result {
                result := and(add(value, 31), not(31))
            }
        }
    }
}
